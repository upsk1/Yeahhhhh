
| 문제                                                                        | 분류           | 티어  |   
|---------------------------------------------------------------------------|--------------|-----|   
| [미로탈출명령어](https://school.programmers.co.kr/learn/courses/30/lessons/150365) | BackTracking | LV3 |

# 문제 풀이

조금은 까다로운 문제라고 생각한다.   
저번에 풀었던 dfs를 이용해서 탐색 순서를 조정해 자동으로 문자열의 정렬 조건을 오름차순으로 정렬하는 코드를 작성한 적이 있어서 바로 접근할 수 있었다.   

n과 m이 최대 50이고, k가 최대 2500이라 시간초과를 피할 수 있을지 확신이 안섰다.   

초기 dfs를 사용해서 d -> l -> r -> u의 순서로 탐색해 문자열을 정렬하고, 도착한 경우 그때의 문자열만 리턴하고 백트래킹 처리를 했다.  

하지만, 메모리 초과가 발생했고, bfs로 풀이를 수정했고 메모리 초과라는 결과를 받았다.   
결국 시간초과를 해결하는 추가적인 테크닉이 필요하다고 생각했고, 백트래킹의 조건을 자세하게 작성해보기로 했다.

탐색을 하는 과정에서 현재 좌표에서 남은 거리가 이동할 수 있는 횟수보다 큰 경우는 절대 도착하지 못하기 때문에 그 경우를 처리해줬다.   
마지막 테스트케이스에서 시간초과가 발생해서 추가적인 가지치기 조건을 생각해보다가, 남은 횟수 - 잔여 거리가 홀수인 경우 되돌아오는 움직임이 없기 때문에 도착할 수 없다는 사실을 깨닥고, 그에 따른 조건을 추가해서 통과할 수 있었다.   

최악으로는 O(4^K)이지만, 적절한 가지치기로 통과할 수 있었다.   
(프로그래머스는 시간제한이 안나와있어서 좀 불편하다..)
